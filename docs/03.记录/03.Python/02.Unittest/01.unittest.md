---
title: unittest
date: 2022-04-26 22:08:42
permalink: /pages/a13db2/
categories:
  - 记录
  - Python
  - Unittest
tags:
  - 
titleTag: 原创
---

## 关于学习unittest过程中遇到的一些坑
1. 
 - **问题**：openpyxl读出来的数据看起来是dict实际为str,影响传参断言
 - **原因**：excel只有int和str两种数据类型，并不认识dict
 - **解法**：eval()转换下
2. 
 - **问题**：输出log到控制台和文件中，功能封装后被多个类调用，每调用次数加1，相应的日志输出也加1
 - **原因**：封装后被调用，创建了多个日志收集器，输出文件&控制台只有一个，被调用几次，就创建了几个日志收集器，就收集了几个，最后输出到同一地方
 - **解法**：封装时直接在方法中创建日志收集器，之后在其他类直接调用这一个收集器
3. 

<!-- more -->

## TestCase  测试用例
1. 定义一个测试用例类，必须继承unittest模块中的TestCase类
2. 测试用例类中，一个test开头的就是一条测试用例
3. 将测试用例执行的代码逻辑写到对应的测试方法中
    - 准备用例数据(返回值）
    - 调用被测功能函数(接口)，获取实际结果
    - 断言
```py
# 以下以写死的登录验证功能函数为例
# 定义登录验证功能函数
def login(username,password):
  if username != None and password != None:
    if username == 'admin' and password == 123:
      return {'code':0,'msg':'登录成功'}
    else:
      return {'code':1,'msg':'账号或密码错误'}
  else:
    return {'code':3,'msg':'输入不能为空'}

# 创建测试用例类，并编写测试用例
import unittest
class login_test(unittest.TestCase):
  # 定义一个参数正确的测试用例,注意需要以test开头
  def test_login_ok(self):
    # 1.准备用例数据(参数和预期结果)
    parms = {'user':'admin','passwrod':123}
    expected = {'code':0,'msg':'登录成功'}
    # 执行登录验证功能函数获取实际结果
    res = login(**parms)
    # 断言
    assert res == expected
  # 以下如果需要继续编写执行测试用例，按上述test_login_ok等方式继续编写即可
```

## TestSuite 测试集合/套件
1. 创建测试套件，加载测试用例
2. 创建一个测试用例运行程序
3. 运行测试用例
```py
import unittest
# 一.创建测试套件，加载测试用例
#  1.创建测试套件
suite = unittest.TestSuite()
#  2.创建用例加载器
load = unittest.TestLoader()
#  3.把用例加载器加载用例并且放到测试套件中
suite.addTest(load.discover('路径'))
# 以上1-3注释说明的代码，一行替代方式
suite = unittest.defalutTestLoader.discover('路径')

# 二，创建一个测试用例运行程序
runer = unittest.TextTestRunner()

# 三，运行测试用例
runer.run(suite)
```

## unnittestreprot
```py
pip install unittestreport
from unittestreport import TestRunner
suite = unittest.defaultTestLoader.discover('路径')
run = TestRunner(suite)
run.run()
```

## TestRunner 测试运行
见上面TestSuite

## fixtrue 测试夹具
**一：**
  1. setUp 用例级别的前置：每条用例执行前执行
  2. tearDown 用例级别的后置：每条用例执行后执行
**二：**
  1. setUpclass 测试类级别的前置
  2. tearDownclass 测试类列级别的后置
```py
class Test_xxx(unnittest.TestCase):
  @classmethod
  def setUpclass(cls):
    pass
  @classmethod
  def tearDownclass(cls):
    pass

  def setUp(self):
    pass
  def tearDown(self):
    pass
```

## DDT（Data Driver Test）
1. 测试类前@ddt
2. 测试方法前@list_ddt(测试数据)
3. 测试方法中定义一个参数 用来接受用例数据
```py
import unittest
from unittestreport import ddt,list_data
from XXX import login_check
# 测试数据
aa = [
  {'expected':{'code':'0','msg':'正确'},'parms':{'user':'admin','pwd':123}},
  {'expected':{'code':'1','msg':'错误'},'parms':{'user':'admin','pwd':000}},
]
@ddt
class Test_login(unittest.TestCase):
@list_ddt(aa)
  def test_login(self,items):
    data = items['expected']
    canshu = ilems['parms']
    shiji = login_check(**data)


``` 

### DDT底层原理
有空补

## openpyxl 通过python操作excel文件
pip install openpyxl
1. 把excel解析为**Workbook**：工作薄对象
2. Seet：表单对象
3. Cell：表格对象 
```py
# 读
# 1.导入openpyxl模块，解析指定excel
workbook = openpyxl.load_workbook('excel路径')
# 2.指定解析的sheet
sheet = workbook['sheet名']
# 3.按行读取cell并转换为list存储
cell = list(sheet.rows)
# 4.此时cell是一个列表嵌套元组的形式，元祖包括读取到的cell表格，用下标取值后遍历，单个的cell拥有value方法，可读取单个cell格子的值
data = [i.value for i in cell[0]]
# 5.此时data为该sheet的第一行的所有值
print(data)

# 写
# 1.导入openpyxl模块，解析指定excel
workbook = openpyxl.load_workbook('excel路径')
# 2.指定解析的sheet
sheet = workbook['sheet名']
# 3.写入需要cell方法并传入row,column,value
sheet.cell(row=1,colum=1,'hello')
# 4.此时数据在该sheet的第一行，第一列即A1的单元格写入了hello，但此时表中数据还没有变，需要保存
workbook.save('excel路径')
```
### demo(读取excel表中数据并使用ddt数据驱动执行用例，执行后执行结果回写到excel表中)
```py
# 封装下读写文件的
import openpyxl

class Openpyxl():
  def __init__(self,excelpath,sheetname):
    self.excelpath = excelpath
    self.sheetname = sheetname

  def read_pyxl(self):
    # 1.指定读取的excel
    workbook = openpyxl.load_workbook(self.excelpath)
    # 2.指定sheet
    sheet = workbook[self.sheetname]
    # 3.按行读取表中所有数据，并以列表形式储存
    cell = list(sheet.rows)
    # 4.遍历字典取出title
```

## 配置文件相关
### ini文件
```py
from configparser import ConfigParser
# 创建conf对象
conf = ConfigParser()
# 读取相关配置文件
conf.read('path')
# 获取配置项的值,get 方法传入配置块的名称 和 配置项的名称
# [mylog]
# name = mylog
# level = DEBUG
# filename = log.txt
level = conf.get('mylog','level')
print(level)
# level=DEBUG
```
### json文件
```py
import json
# 打开并读取json文件
with open('path','权限',encoding='utf-8') as f:
  data = json.load(f)
print(data)
# data=被转化为pthon的json字符串，data=dict
# 如json字符串中,对象=字典,数组=列表,true=True,null=None,false=False 前者为json字符串中的表示形式，后者为python

# 将data转换为json字符串，data=str
json.dumps(data)
# 将data转换为python数据，data=dict
json.loads(data)

# 总结：
# 1.load()读取json文件转换为python数据
# 2.dumps()将python数据转换为json字符串
# 3.loads()将json字符串转换为python数据
```