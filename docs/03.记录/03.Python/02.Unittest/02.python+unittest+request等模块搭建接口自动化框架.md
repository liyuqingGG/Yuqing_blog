---
title: python+unittest+request等模块搭建接口自动化框架
date: 2022-05-26 11:58:18
permalink: /pages/8d13e3/
categories:
  - 记录
  - Python
  - Unittest
tags:
  - 
titleTag: 原创
---

- 关于搭建借口自动化框架过程中遇到的一些坑
1. 
 - **问题**：excel中写的用例请求参数类型为dict,通过openpyxl读取出来为str
 - **原因**：excel只有int和str两种数据类型，并不认识dict
 - **解法**：eval()转换下
2. 
 - **问题**：输出log到控制台和文件中，功能封装后被多个测试类调用，每调用次数加1，相应的日志输出也加1
 - **原因**：封装后被调用，创建了多个日志收集器，输出文件&控制台只有一个，被调用几次，就创建了几个日志收集器，就收集了几个，最后输出到同一地方
 - **解法**：封装好直接在py文件中创建日志收集器，之后在其他类直接调用这一个收集器
 <!-- more -->
3. 
 - **问题**：pymysql进行数据库校验，接口请求钱前和接口请求后分别查库，结果显示一致，导致断言失败
 - **原因**：pymysql0.9.3版本支持with写法 不用手动commit 新版中不支持with写法 需要手动commit 在封装方法中忘记commit了
 - **解法**：封装方法中使用数据库连接对象调用.commit()方法

 ## 目录结构--demo
 ```python
├── common # 封装的公共方法文件夹，直接调用
│   ├── handle_conf.py # 读取配置文件内容 configparser
│   ├── handle_excel.py # 操作excel openpyxl
│   ├── handle_log.py # log收集输出 logging
│   ├── handle_mysql.py # 操作数据库 pymysql
│   ├── handle_path.py # 路径优化 os
│   └── handle_re.py # 正则提取 re
├── conf # 配置文件存放文件夹
│   └── conf.ini 
├── datas # 用例数据存放文件夹
│   └── demo_data.xlsx
├── logs # 输出日志存放文件夹
│   └── log.txt
├── reports # 测试报告生成文件夹
│   └── report.html
├── run.py # 测试启动运行文件
└── test_cases # 测试用例
    ├── super_cls.py # 封装的前置条件
    ├── test_01_register.py # 模块1用例
    └── test_02_login.py # 模块2用例
```
## pip list
```python
jsonpath       0.82
openpyxl       3.0.9
PyMySQL        1.0.2
PyYAML         5.3.1
requests       2.24.0
unittestreport 1.4.0
```

## 读写excel表封装 openpyxl
handle_excel.py

```python
import openpyxl

# 处理excel

class handle_excel:

    def __init__(self,excel_path,sheet_name):
        self.excel_path = excel_path
        self.sheet_name = sheet_name

    # 读
    def read(self):
        workbook = openpyxl.load_workbook(self.excel_path)
        sheet = workbook[self.sheet_name]
        cells = list(sheet.rows)
        title = [i.value for i in cells[0]]
        list_data = []

        for items in cells[1:]:
            data = [i.value for i in items]
            new_data = dict(zip(title,data))
            list_data.append(new_data)

        return list_data
    # 写
    def write(self,row,column,value):
        workbook = openpyxl.load_workbook(self.excel_path)
        sheet = workbook[self.sheet_name]
        sheet.cell(row=row,column=column,value=value)

        workbook.save(self.excel_path)

```
## 项目路径优化处理 os
handle_path.py
```python
import os

# 当前项目根目录
ROOT_PATH = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# 用例数据路径
DATAS_PATH = os.path.join(ROOT_PATH,'datas')

# 配置文件路径
Conf_PATH = os.path.join(ROOT_PATH,'conf')

# 日志文件路径
Logs_PATH = os.path.join(ROOT_PATH,'logs')

# 测试用例路径
Test_cases_PATH = os.path.join(ROOT_PATH,'test_cases')
```

## 读取配置文件 configparser
handle_conf.py
```python
from configparser import ConfigParser
import os
from common.handle_path import Conf_PATH
class handle_conf(ConfigParser):
    def __init__(self,conf_path):
        super().__init__()
        self.read(conf_path)

conf = handle_conf(os.path.join(Conf_PATH,'conf.ini'))
```

## 日志收集 logging
handle_log.py
```python
import logging
import os
from common.handle_conf import conf # 导入配置文件读取方法
from common.handle_path import Logs_PATH # 导入日志输出路径
def  handle_log(log_name,log_level,file_name,file_level,str_level):
    log = logging.getLogger(log_name)
    # 设置日志收集等级
    log.setLevel(log_level)

    file_log = logging.FileHandler(file_name,encoding='utf-8')
    # 设置日志输出等级 --- 文件
    file_log.setLevel(file_level)
    log.addHandler(file_log)

    str_log = logging.StreamHandler()
    # 设置日志输出等级 --- 控制台
    str_log.setLevel(str_level)
    log.addHandler(str_log)

    # 日志输出格式
    type = logging.Formatter('日志输出的格式')
    file_log.setFormatter(type)
    str_log.setFormatter(type)


    return log

# 创建一个日志收集器对象，其他类只调用这一个即可，避免日志重复收集
my_log = handle_log(
    log_name = conf.get('logging','log_name'), # 参数来自配置文件
    log_level = conf.get('logging','log_level'),
    file_name = os.path.join(Logs_PATH,conf.get('logging','file_name')),
    file_level = conf.get('logging','file_level'),
    str_level = conf.get('logging','str_level')
)

```

## 正则替换 re
handle_re.py
```python
import re
from common.handle_conf import conf
def handle_re(str,cls):
    while re.search('#(.+?)#',str):
        # 匹配到需要替换的字符对象
        re_1 = re.search('#(.+?)#',str)
        # 获取需要替换的字符
        re_2 = re_1.group()
        # 获取要替换属性的名称
        re_3 = re_1.group(1)
        # 通过类属性获取要替换的值
        # 如果类属性没有找到要替换的值，那么去配置文件找
        try:
            re_4 = getattr(cls,re_3)
        except AttributeError:
            re_4 = conf.get('test_data',re_2) 
        # 替换该字符串中的值
        str = str.replace(re_2,re_4)

    return str
```

## 前置登录处理+处理token鉴权封装
super_cls
```python
import requests
from jsonpath import jsonpath
from common.handle_conf import conf

class BASA_DATA:

    @classmethod
    def user_login(cls):
        # 配置文件读取测试用的登录用户账号信息
        headers = eval(conf.get('env', 'headers'))
        login_url = conf.get('env', 'url') + '登录接口地址'
        login_params = {
            'phone': conf.get('test_data', 'phone'),
            'pwd': conf.get('test_data', 'pwd')
        }

        # 发送请求
        response = requests.post(url=login_url, headers=headers, json=login_params)
        # 获取返回结果
        login_res = response.json()

        # jsonpath提取token
        token = jsonpath(login_res, '$..token')
        # 更新headers并保存为类属性
        headers['Authorization'] = 'Bearer ' + token[0]
        cls.headers = headers
        # token提取完成，并已经保存到请求头中，登录后才能进行操作的模块，前置条件中直接调用此方法即可setupclass
```

## 运行测试用例+生成测试报告+邮箱推送
run.py
```python
import unittest
from unittestreport import TestRunner
from common.handle_path import Test_cases_PATH


def main():
    # 用例收集
    suite = unittest.defaultTestLoader.discover(Test_cases_PATH)
    # 套件加载
    runner = TestRunner(suite,
                        title='demo',
                        tester='liyuqing',
                        desc="demo项目测试生成的报告",
                        )
    # 运行
    runner.run()

    # 邮箱推送测试结果
    # 首先要开通邮箱smtp服务，获取授权码
    runner.send_email(host='smtp.qq.com', # smtp服务器地址
                      port=456, # smtp服务器地址端口
                      user='1923313276@qq.com', # 发送人邮箱账号
                      password='授权码',  # smtp授权码
                      to_addrs='1923313276@qq.com',# 收件人邮箱账号，群发传list，单发str
                      )

if __name__ == '__main__':
    main()
```
![邮箱]https://fastly.jsdelivr.net/gh/liyuqinggg/cdn@1.5/qq_01.png

